{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-8db243d8144a16d22800efe66a569e507012c6c2",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/AddressBook.sol": "project/contracts/AddressBook.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 50
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/AddressBook.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport {OrganizationRegistry} from \"./OrganizationRegistry.sol\";\r\nimport {BatchRegistry} from \"./BatchRegistry.sol\";\r\nimport {CertRegistry} from \"./CertRegistry.sol\";\r\nimport {TelemetryAnchor} from \"./TelemetryAnchor.sol\";\r\nimport {RoleManager} from \"./RoleManager.sol\";\r\n\r\ncontract AddressBook is RoleManager {\r\n    OrganizationRegistry public orgs;\r\n    BatchRegistry public batches;\r\n    CertRegistry public certs;\r\n    TelemetryAnchor public telemetry;\r\n\r\n    event Linked(\r\n        address orgs,\r\n        address batches,\r\n        address certs,\r\n        address telemetry\r\n    );\r\n\r\n    /// @notice Gán địa chỉ các contract đã deploy sẵn\r\n    function link(\r\n        address _orgs,\r\n        address _batches,\r\n        address _certs,\r\n        address _telemetry\r\n    ) external onlyOwner {\r\n        require(_orgs != address(0), \"ZERO_ADDR\");\r\n        require(_batches != address(0), \"ZERO_ADDR\");\r\n        require(_certs != address(0), \"ZERO_ADDR\");\r\n        require(_telemetry != address(0), \"ZERO_ADDR\");\r\n\r\n        orgs = OrganizationRegistry(_orgs);\r\n        batches = BatchRegistry(_batches);\r\n        certs = CertRegistry(_certs);\r\n        telemetry = TelemetryAnchor(_telemetry);\r\n\r\n        emit Linked(_orgs, _batches, _certs, _telemetry);\r\n    }\r\n}\r\n"
      },
      "project/contracts/BatchRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\nimport {OrganizationRegistry} from \"./OrganizationRegistry.sol\";\r\nimport {Types} from \"../libs/Types.sol\";\r\ncontract BatchRegistry {\r\n    OrganizationRegistry public orgs;\r\n    uint256 private _batchSeq;\r\n    uint256 private _eventSeq;\r\n    mapping(uint256 => Types.Batch) private _batchById;\r\n    mapping(uint256 => uint256[]) private _childrenOf;\r\n    mapping(uint256 => Types.BatchEvent[]) private _eventsOf;\r\n    bool public paused;\r\n\r\n    event Paused(bool status);\r\n    event BatchCreated(\r\n        uint256 indexed batchId,\r\n        uint256 parentId,\r\n        uint256 ownerOrgId,\r\n        string productType,\r\n        string metadataCid,\r\n        bytes32 dataHash\r\n    );\r\n    event BatchEventAppended(\r\n        uint256 indexed eventId,\r\n        uint256 indexed batchId,\r\n        Types.EventType eventType,\r\n        uint256 actorOrgId,\r\n        string metadataCid,\r\n        bytes32 dataHash\r\n    );\r\n    event OwnerTransferred(\r\n        uint256 indexed batchId,\r\n        uint256 oldOwnerOrgId,\r\n        uint256 newOwnerOrgId\r\n    );\r\n    event BatchStatusUpdated(\r\n        uint256 indexed batchId,\r\n        Types.BatchStatus oldStatus,\r\n        Types.BatchStatus newStatus\r\n    );\r\n\r\n    constructor(OrganizationRegistry _orgs) {\r\n        orgs = _orgs;\r\n    }\r\n\r\n    modifier onlyActiveOrg() {\r\n        uint256 orgId = orgs.orgIdOf(msg.sender);\r\n        require(orgId != 0, \"ORG_NOT_REGISTERED\");\r\n        Types.Organization memory org = orgs.getOrganization(orgId);\r\n        require(org.active, \"ORG_NOT_ACTIVE\");\r\n        _;\r\n    }\r\n\r\n    modifier notPaused() {\r\n        require(!paused, \"CONTRACT_PAUSED\");\r\n        _;\r\n    }\r\n\r\n    function setPaused(bool _p) external {\r\n        address s = msg.sender;\r\n        require(orgs.superAdmins(s) || s == orgs.owner(), \"NO_AUTH\");\r\n        paused = _p;\r\n        emit Paused(_p);\r\n    }\r\n\r\n    function createBatch(\r\n        string calldata productType,\r\n        string calldata metadataCid,\r\n        bytes32 dataHash,\r\n        uint256 parentId\r\n    ) external notPaused onlyActiveOrg returns (uint256 id) {\r\n        (uint256 ownerOrgId, ) = _requireSenderOrgActive();\r\n        return\r\n            _createBatch(\r\n                ownerOrgId,\r\n                productType,\r\n                metadataCid,\r\n                dataHash,\r\n                parentId\r\n            );\r\n    }\r\n\r\n    function _createBatch(\r\n        uint256 ownerOrgId,\r\n        string memory productType,\r\n        string memory metadataCid,\r\n        bytes32 dataHash,\r\n        uint256 parentId\r\n    ) internal returns (uint256 id) {\r\n        if (parentId != 0) {\r\n            require(_batchById[parentId].id != 0, \"PARENT_NOT_FOUND\");\r\n        }\r\n\r\n        id = ++_batchSeq;\r\n        Types.Batch storage b = _batchById[id];\r\n        b.id = id;\r\n        b.parentId = parentId;\r\n        b.ownerOrgId = ownerOrgId;\r\n        b.status = parentId == 0\r\n            ? Types.BatchStatus.HARVESTED\r\n            : _batchById[parentId].status;\r\n        b.productType = productType;\r\n        b.metadataCid = metadataCid;\r\n        b.dataHash = dataHash;\r\n        b.createdAt = block.timestamp;\r\n\r\n        if (parentId != 0) {\r\n            _childrenOf[parentId].push(id);\r\n        }\r\n\r\n        emit BatchCreated(\r\n            id,\r\n            parentId,\r\n            ownerOrgId,\r\n            productType,\r\n            metadataCid,\r\n            dataHash\r\n        );\r\n    }\r\n\r\n    function transferBatchOwner(\r\n        uint256 batchId,\r\n        uint256 newOwnerOrgId\r\n    ) external notPaused onlyActiveOrg {\r\n        Types.Batch storage b = _requireBatchOwnedBySender(batchId);\r\n        Types.Organization memory target = orgs.getOrganization(newOwnerOrgId);\r\n        require(target.id != 0 && target.active, \"TARGET_INACTIVE\");\r\n        uint256 old = b.ownerOrgId;\r\n        b.ownerOrgId = newOwnerOrgId;\r\n        emit OwnerTransferred(batchId, old, newOwnerOrgId);\r\n    }\r\n\r\n    function updateBatchStatus(\r\n        uint256 batchId,\r\n        Types.BatchStatus newStatus\r\n    ) external notPaused onlyActiveOrg {\r\n        Types.Batch storage b = _requireBatchOwnedBySender(batchId);\r\n        Types.BatchStatus old = b.status;\r\n        require(uint(newStatus) >= uint(old), \"INVALID_STATE_BACKWARD\");\r\n        b.status = newStatus;\r\n        emit BatchStatusUpdated(batchId, old, newStatus);\r\n    }\r\n\r\n    function splitBatch(\r\n        uint256 batchId,\r\n        uint256 numChildren\r\n    ) external notPaused onlyActiveOrg returns (uint256[] memory childIds) {\r\n        require(numChildren > 0 && numChildren <= 64, \"BAD_COUNT\");\r\n        Types.Batch storage parent = _requireBatchOwnedBySender(batchId);\r\n        (uint256 ownerOrgId, ) = _requireSenderOrgActive();\r\n\r\n        childIds = new uint256[](numChildren);\r\n        for (uint256 i = 0; i < numChildren; i++) {\r\n            uint256 cid = _createBatch(\r\n                ownerOrgId,\r\n                parent.productType,\r\n                parent.metadataCid,\r\n                parent.dataHash,\r\n                batchId\r\n            );\r\n            childIds[i] = cid;\r\n        }\r\n    }\r\n\r\n    function mergeBatches(\r\n        uint256[] calldata sources,\r\n        string calldata productType,\r\n        string calldata metadataCid,\r\n        bytes32 dataHash\r\n    ) external notPaused onlyActiveOrg returns (uint256 mergedId) {\r\n        require(sources.length >= 2 && sources.length <= 64, \"BAD_SOURCES\");\r\n        (uint256 actorOrgId, ) = _requireSenderOrgActive();\r\n\r\n        for (uint256 i = 0; i < sources.length; i++) {\r\n            Types.Batch storage sb = _requireBatchOwnedBySender(sources[i]);\r\n            require(\r\n                sb.status != Types.BatchStatus.RECALLED &&\r\n                    sb.status != Types.BatchStatus.FROZEN,\r\n                \"SRC_LOCKED\"\r\n            );\r\n        }\r\n\r\n        mergedId = _createBatch(\r\n            actorOrgId,\r\n            productType,\r\n            metadataCid,\r\n            dataHash,\r\n            0\r\n        );\r\n        for (uint256 i = 0; i < sources.length; i++) {\r\n            _appendEventInternal(\r\n                sources[i],\r\n                Types.EventType.PROCESS,\r\n                actorOrgId,\r\n                metadataCid,\r\n                dataHash\r\n            );\r\n        }\r\n        _appendEventInternal(\r\n            mergedId,\r\n            Types.EventType.PROCESS,\r\n            actorOrgId,\r\n            metadataCid,\r\n            dataHash\r\n        );\r\n    }\r\n\r\n    function appendEvent(\r\n        uint256 batchId,\r\n        Types.EventType eventType,\r\n        string calldata metadataCid,\r\n        bytes32 dataHash\r\n    ) external notPaused onlyActiveOrg returns (uint256 eventId) {\r\n        (uint256 actorOrgId, ) = _requireSenderOrgActive();\r\n        return\r\n            _appendEventInternal(\r\n                batchId,\r\n                eventType,\r\n                actorOrgId,\r\n                metadataCid,\r\n                dataHash\r\n            );\r\n    }\r\n    function _appendEventInternal(\r\n        uint256 batchId,\r\n        Types.EventType eventType,\r\n        uint256 actorOrgId,\r\n        string calldata metadataCid,\r\n        bytes32 dataHash\r\n    ) internal returns (uint256 eventId) {\r\n        Types.Batch storage b = _batchById[batchId];\r\n        require(b.id != 0, \"BATCH_NOT_FOUND\");\r\n        eventId = ++_eventSeq;\r\n        Types.BatchEvent memory ev = Types.BatchEvent({\r\n            id: eventId,\r\n            batchId: batchId,\r\n            eventType: eventType,\r\n            actorOrgId: actorOrgId,\r\n            metadataCid: metadataCid,\r\n            dataHash: dataHash,\r\n            at: block.timestamp\r\n        });\r\n        _eventsOf[batchId].push(ev);\r\n        emit BatchEventAppended(\r\n            eventId,\r\n            batchId,\r\n            eventType,\r\n            actorOrgId,\r\n            metadataCid,\r\n            dataHash\r\n        );\r\n    }\r\n\r\n    function getBatch(uint256 id) external view returns (Types.Batch memory) {\r\n        return _batchById[id];\r\n    }\r\n    function getChildren(uint256 id) external view returns (uint256[] memory) {\r\n        return _childrenOf[id];\r\n    }\r\n    function getEvents(\r\n        uint256 batchId\r\n    ) external view returns (Types.BatchEvent[] memory) {\r\n        return _eventsOf[batchId];\r\n    }\r\n\r\n    function _requireSenderOrgActive()\r\n        internal\r\n        view\r\n        returns (uint256 orgId, bool active)\r\n    {\r\n        orgId = orgs.orgIdOf(msg.sender);\r\n        Types.Organization memory o = orgs.getOrganization(orgId);\r\n        active = o.active;\r\n    }\r\n    function _requireBatchOwnedBySender(\r\n        uint256 batchId\r\n    ) internal view returns (Types.Batch storage b) {\r\n        uint256 orgId = orgs.orgIdOf(msg.sender);\r\n        b = _batchById[batchId];\r\n        require(b.id != 0, \"BATCH_NOT_FOUND\");\r\n        require(b.ownerOrgId == orgId, \"NOT_OWNER_ORG\");\r\n    }\r\n}\r\n"
      },
      "project/contracts/CertRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\nimport {Types} from \"../libs/Types.sol\";\r\nimport {OrganizationRegistry} from \"./OrganizationRegistry.sol\";\r\ncontract CertRegistry {\r\n    OrganizationRegistry public orgs;\r\n    uint256 private _certSeq;\r\n    mapping(uint256 => Types.Certification) private _certById;\r\n\r\n    event CertIssued(\r\n        uint256 indexed id,\r\n        bytes32 indexed subject,\r\n        uint256 issuerOrgId,\r\n        string metadataCid,\r\n        uint64 expireAt\r\n    );\r\n    event CertRevoked(uint256 indexed id);\r\n\r\n    modifier onlyAuditor() {\r\n        uint256 orgId = orgs.orgIdOf(msg.sender);\r\n        require(orgId != 0, \"ORG_NOT_REGISTERED\");\r\n        Types.Organization memory org = orgs.getOrganization(orgId);\r\n        require(org.active, \"ORG_NOT_ACTIVE\");\r\n        require(\r\n            org.orgType == Types.OrgType.AUDITOR,\r\n            \"ORG_NOT_AUTHORIZED_AS_AUDITOR\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(OrganizationRegistry _orgs) {\r\n        orgs = _orgs;\r\n    }\r\n\r\n    function issueCert(\r\n        bytes32 subject,\r\n        string calldata metadataCid,\r\n        uint64 expireAt\r\n    ) external onlyAuditor returns (uint256 id) {\r\n        id = ++_certSeq;\r\n        uint256 issuerOrgId = orgs.orgIdOf(msg.sender);\r\n        _certById[id] = Types.Certification({\r\n            id: id,\r\n            subject: subject,\r\n            issuerOrgId: issuerOrgId,\r\n            metadataCid: metadataCid,\r\n            expireAt: expireAt,\r\n            active: true\r\n        });\r\n        emit CertIssued(id, subject, issuerOrgId, metadataCid, expireAt);\r\n    }\r\n\r\n    function revokeCert(uint256 id) external onlyAuditor {\r\n        Types.Certification storage cert = _certById[id];\r\n        require(cert.id != 0, \"CERT_NOT_FOUND\");\r\n        require(cert.active, \"CERT_ALREADY_REVOKED\");\r\n        uint256 issuerOrgId = orgs.orgIdOf(msg.sender);\r\n        require(\r\n            cert.issuerOrgId == issuerOrgId,\r\n            \"NOT_AUTHORIZED_TO_REVOKE_CERT\"\r\n        );\r\n        cert.active = false;\r\n        emit CertRevoked(id);\r\n    }\r\n\r\n    function getCert(\r\n        uint256 id\r\n    ) external view returns (Types.Certification memory) {\r\n        return _certById[id];\r\n    }\r\n}\r\n"
      },
      "project/contracts/OrganizationRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\nimport {RoleManager} from \"./RoleManager.sol\";\r\nimport {Types} from \"../libs/Types.sol\";\r\ncontract OrganizationRegistry is RoleManager {\r\n    uint256 private _orgSeq;\r\n    mapping(uint256 => Types.Organization) private _orgById;\r\n    mapping(address => uint256) public orgIdOf;\r\n    event OrganizationRegistered(\r\n        uint256 indexed id,\r\n        address indexed wallet,\r\n        Types.OrgType orgType,\r\n        string name,\r\n        string metadataCid,\r\n        bool active\r\n    );\r\n\r\n    event OrganizationUpdated(\r\n        uint256 indexed id,\r\n        address indexed wallet,\r\n        Types.OrgType orgType,\r\n        string name,\r\n        string metadataCid,\r\n        bool active\r\n    );\r\n\r\n    function registerOrganization(\r\n        address wallet,\r\n        Types.OrgType orgType,\r\n        string calldata name,\r\n        string calldata metadataCid,\r\n        bool active\r\n    ) external onlySuperAdmin returns (uint256 id) {\r\n        require(wallet != address(0), \"INVALID_WALLET\");\r\n        require(orgType != Types.OrgType.NONE, \"INVALID_ORG_TYPE\");\r\n        require(orgIdOf[wallet] == 0, \"ORG_ALREADY_REGISTERED\");\r\n        id = ++_orgSeq;\r\n        _orgById[id] = Types.Organization({\r\n            id: id,\r\n            wallet: wallet,\r\n            orgType: orgType,\r\n            name: name,\r\n            metadataCid: metadataCid,\r\n            active: active\r\n        });\r\n\r\n        orgIdOf[wallet] = id;\r\n        emit OrganizationRegistered(\r\n            id,\r\n            wallet,\r\n            orgType,\r\n            name,\r\n            metadataCid,\r\n            active\r\n        );\r\n    }\r\n\r\n    function updateOrganization(\r\n        uint256 id,\r\n        address wallet,\r\n        Types.OrgType orgType,\r\n        string calldata name,\r\n        string calldata metadataCid,\r\n        bool active\r\n    ) external onlySuperAdmin {\r\n        Types.Organization storage org = _orgById[id];\r\n        require(org.id != 0, \"ORG_NOT_FOUND\");\r\n        if (wallet != address(0) && wallet != org.wallet) {\r\n            require(orgIdOf[wallet] == 0, \"WALLET_ALREADY_REGISTERED\");\r\n            delete orgIdOf[org.wallet];\r\n            org.wallet = wallet;\r\n            orgIdOf[wallet] = id;\r\n        }\r\n\r\n        if (orgType != Types.OrgType.NONE) {\r\n            org.orgType = orgType;\r\n        }\r\n\r\n        org.orgType = orgType;\r\n        org.name = name;\r\n        org.metadataCid = metadataCid;\r\n        org.active = active;\r\n\r\n        emit OrganizationUpdated(\r\n            id,\r\n            org.wallet,\r\n            orgType,\r\n            name,\r\n            metadataCid,\r\n            active\r\n        );\r\n    }\r\n\r\n    function getOrganization(\r\n        uint256 id\r\n    ) external view returns (Types.Organization memory) {\r\n        return _orgById[id];\r\n    }\r\n}\r\n"
      },
      "project/contracts/RoleManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract RoleManager {\r\n    address public owner;\r\n\r\n    mapping(address => bool) public superAdmins;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    event SuperAdminSet(address indexed account, bool enabled);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySuperAdmin() {\r\n        require(\r\n            superAdmins[msg.sender] || msg.sender == owner,\r\n            \"NOT_SUPER_ADMIN\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        superAdmins[msg.sender] = true;\r\n        emit SuperAdminSet(msg.sender, true);\r\n    }\r\n\r\n    function tranferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"INVALID_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setSuperAdmin(address account, bool enabled) external onlyOwner {\r\n        superAdmins[account] = enabled;\r\n        emit SuperAdminSet(account, enabled);\r\n    }\r\n}\r\n"
      },
      "project/contracts/TelemetryAnchor.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport {OrganizationRegistry} from \"./OrganizationRegistry.sol\";\r\nimport {Types} from \"../libs/Types.sol\";\r\n\r\ncontract TelemetryAnchor {\r\n    OrganizationRegistry public orgs;\r\n    struct Anchor {\r\n        uint256 id;\r\n        bytes32 root;\r\n        uint256 refId;\r\n        uint8 refType;\r\n        uint64 fromTs;\r\n        uint64 toTs;\r\n        string storageUri;\r\n        uint256 actorOrgId;\r\n    }\r\n    uint256 private _seq;\r\n    mapping(uint256 => Anchor) private _byId;\r\n    mapping(uint256 => uint256[]) private _byRef;\r\n    event TelemetryAnchored(\r\n        uint256 indexed id,\r\n        bytes32 root,\r\n        uint8 refType,\r\n        uint256 refId,\r\n        uint64 fromTs,\r\n        uint64 toTs,\r\n        string storageUri,\r\n        uint256 actorOrgId\r\n    );\r\n    modifier onlyActiveOrg() {\r\n        uint256 orgId = orgs.orgIdOf(msg.sender);\r\n        Types.Organization memory o = orgs.getOrganization(orgId);\r\n        require(o.id != 0 && o.active, \"ORG_INACTIVE\");\r\n        _;\r\n    }\r\n    constructor(OrganizationRegistry _orgs) {\r\n        orgs = _orgs;\r\n    }\r\n    function anchor(\r\n        bytes32 root,\r\n        uint8 refType,\r\n        uint256 refId,\r\n        uint64 fromTs,\r\n        uint64 toTs,\r\n        string calldata storageUri\r\n    ) external onlyActiveOrg returns (uint256 id) {\r\n        require(root != bytes32(0), \"ROOT_ZERO\");\r\n        require(refType == 1 || refType == 2, \"BAD_REFTYPE\");\r\n        require(fromTs <= toTs, \"BAD_RANGE\");\r\n        id = ++_seq;\r\n        uint256 orgId = orgs.orgIdOf(msg.sender);\r\n        Anchor memory a = Anchor({\r\n            id: id,\r\n            root: root,\r\n            refId: refId,\r\n            refType: refType,\r\n            fromTs: fromTs,\r\n            toTs: toTs,\r\n            storageUri: storageUri,\r\n            actorOrgId: orgId\r\n        });\r\n        _byId[id] = a;\r\n        uint256 refKey = (uint256(refType) << 248) | refId;\r\n        _byRef[refKey].push(id);\r\n        emit TelemetryAnchored(\r\n            id,\r\n            root,\r\n            refType,\r\n            refId,\r\n            fromTs,\r\n            toTs,\r\n            storageUri,\r\n            orgId\r\n        );\r\n    }\r\n    function get(uint256 id) external view returns (Anchor memory) {\r\n        return _byId[id];\r\n    }\r\n    function getByRef(\r\n        uint8 refType,\r\n        uint256 refId\r\n    ) external view returns (Anchor[] memory out) {\r\n        uint256 refKey = (uint256(refType) << 248) | refId;\r\n        uint256[] memory ids = _byRef[refKey];\r\n        out = new Anchor[](ids.length);\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            out[i] = _byId[ids[i]];\r\n        }\r\n    }\r\n}\r\n"
      },
      "project/libs/Types.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nlibrary Types {\r\n    enum OrgType {\r\n        NONE,\r\n        FARM,\r\n        PRCESSOR,\r\n        LOGISTICS,\r\n        RETAILER,\r\n        AUDITOR,\r\n        ADMIN\r\n    }\r\n    enum BatchStatus {\r\n        NONE,\r\n        HARVESTED,\r\n        PROCESSED,\r\n        PACKAGED,\r\n        IN_TRANSIT,\r\n        IN_WAREHOUSE,\r\n        IN_RETAIL,\r\n        SOLD,\r\n        FROZEN,\r\n        RECALLED\r\n    }\r\n\r\n    enum EventType {\r\n        NONE,\r\n        HARVEST,\r\n        PROCESS,\r\n        PACKAGE_,\r\n        SHIP_START,\r\n        SHIP_END,\r\n        WAREHOUSE_IN,\r\n        WAREHOUSE_OUT,\r\n        RETAIL_IN,\r\n        RETAIL_OUT,\r\n        SOLD,\r\n        FREEZE_,\r\n        RECALL_\r\n    }\r\n\r\n    struct Organization {\r\n        uint256 id;\r\n        address wallet;\r\n        OrgType orgType;\r\n        string name;\r\n        string metadataCid;\r\n        bool active;\r\n    }\r\n\r\n    struct Batch {\r\n        uint256 id;\r\n        uint256 parentId;\r\n        uint256 ownerOrgId;\r\n        BatchStatus status;\r\n        string productType;\r\n        string metadataCid;\r\n        bytes32 dataHash;\r\n        uint256 createdAt;\r\n    }\r\n\r\n    struct BatchEvent {\r\n        uint256 id;\r\n        uint256 batchId;\r\n        EventType eventType;\r\n        uint256 actorOrgId;\r\n        string metadataCid;\r\n        bytes32 dataHash;\r\n        uint256 at;\r\n    }\r\n\r\n    struct Certification {\r\n        uint256 id;\r\n        bytes32 subject;\r\n        uint256 issuerOrgId;\r\n        string metadataCid;\r\n        uint256 expireAt;\r\n        bool active;\r\n    }\r\n}\r\n"
      }
    }
  }
}