{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-8326891473e25b3281f14dcf88aca63af66e97db",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/CertRegistry.sol": "project/contracts/CertRegistry.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 50
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/CertRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\nimport {Types} from \"../libs/Types.sol\";\r\nimport {OrganizationRegistry} from \"./OrganizationRegistry.sol\";\r\ncontract CertRegistry {\r\n    OrganizationRegistry public orgs;\r\n    uint256 private _certSeq;\r\n    mapping(uint256 => Types.Certification) private _certById;\r\n\r\n    event CertIssued(\r\n        uint256 indexed id,\r\n        bytes32 indexed subject,\r\n        uint256 issuerOrgId,\r\n        string metadataCid,\r\n        uint64 expireAt\r\n    );\r\n    event CertRevoked(uint256 indexed id);\r\n\r\n    modifier onlyAuditor() {\r\n        uint256 orgId = orgs.orgIdOf(msg.sender);\r\n        require(orgId != 0, \"ORG_NOT_REGISTERED\");\r\n        Types.Organization memory org = orgs.getOrganization(orgId);\r\n        require(org.active, \"ORG_NOT_ACTIVE\");\r\n        require(\r\n            org.orgType == Types.OrgType.AUDITOR,\r\n            \"ORG_NOT_AUTHORIZED_AS_AUDITOR\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(OrganizationRegistry _orgs) {\r\n        orgs = _orgs;\r\n    }\r\n\r\n    function issueCert(\r\n        bytes32 subject,\r\n        string calldata metadataCid,\r\n        uint64 expireAt\r\n    ) external onlyAuditor returns (uint256 id) {\r\n        id = ++_certSeq;\r\n        uint256 issuerOrgId = orgs.orgIdOf(msg.sender);\r\n        _certById[id] = Types.Certification({\r\n            id: id,\r\n            subject: subject,\r\n            issuerOrgId: issuerOrgId,\r\n            metadataCid: metadataCid,\r\n            expireAt: expireAt,\r\n            active: true\r\n        });\r\n        emit CertIssued(id, subject, issuerOrgId, metadataCid, expireAt);\r\n    }\r\n\r\n    function revokeCert(uint256 id) external onlyAuditor {\r\n        Types.Certification storage cert = _certById[id];\r\n        require(cert.id != 0, \"CERT_NOT_FOUND\");\r\n        require(cert.active, \"CERT_ALREADY_REVOKED\");\r\n        uint256 issuerOrgId = orgs.orgIdOf(msg.sender);\r\n        require(\r\n            cert.issuerOrgId == issuerOrgId,\r\n            \"NOT_AUTHORIZED_TO_REVOKE_CERT\"\r\n        );\r\n        cert.active = false;\r\n        emit CertRevoked(id);\r\n    }\r\n\r\n    function getCert(\r\n        uint256 id\r\n    ) external view returns (Types.Certification memory) {\r\n        return _certById[id];\r\n    }\r\n}\r\n"
      },
      "project/contracts/OrganizationRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\nimport {RoleManager} from \"./RoleManager.sol\";\r\nimport {Types} from \"../libs/Types.sol\";\r\ncontract OrganizationRegistry is RoleManager {\r\n    uint256 private _orgSeq;\r\n    mapping(uint256 => Types.Organization) private _orgById;\r\n    mapping(address => uint256) public orgIdOf;\r\n    event OrganizationRegistered(\r\n        uint256 indexed id,\r\n        address indexed wallet,\r\n        Types.OrgType orgType,\r\n        string name,\r\n        string metadataCid,\r\n        bool active\r\n    );\r\n\r\n    event OrganizationUpdated(\r\n        uint256 indexed id,\r\n        address indexed wallet,\r\n        Types.OrgType orgType,\r\n        string name,\r\n        string metadataCid,\r\n        bool active\r\n    );\r\n\r\n    function registerOrganization(\r\n        address wallet,\r\n        Types.OrgType orgType,\r\n        string calldata name,\r\n        string calldata metadataCid,\r\n        bool active\r\n    ) external onlySuperAdmin returns (uint256 id) {\r\n        require(wallet != address(0), \"INVALID_WALLET\");\r\n        require(orgType != Types.OrgType.NONE, \"INVALID_ORG_TYPE\");\r\n        require(orgIdOf[wallet] == 0, \"ORG_ALREADY_REGISTERED\");\r\n        id = ++_orgSeq;\r\n        _orgById[id] = Types.Organization({\r\n            id: id,\r\n            wallet: wallet,\r\n            orgType: orgType,\r\n            name: name,\r\n            metadataCid: metadataCid,\r\n            active: active\r\n        });\r\n\r\n        orgIdOf[wallet] = id;\r\n        emit OrganizationRegistered(\r\n            id,\r\n            wallet,\r\n            orgType,\r\n            name,\r\n            metadataCid,\r\n            active\r\n        );\r\n    }\r\n\r\n    function updateOrganization(\r\n        uint256 id,\r\n        address wallet,\r\n        Types.OrgType orgType,\r\n        string calldata name,\r\n        string calldata metadataCid,\r\n        bool active\r\n    ) external onlySuperAdmin {\r\n        Types.Organization storage org = _orgById[id];\r\n        require(org.id != 0, \"ORG_NOT_FOUND\");\r\n        if (wallet != address(0) && wallet != org.wallet) {\r\n            require(orgIdOf[wallet] == 0, \"WALLET_ALREADY_REGISTERED\");\r\n            delete orgIdOf[org.wallet];\r\n            org.wallet = wallet;\r\n            orgIdOf[wallet] = id;\r\n        }\r\n\r\n        if (orgType != Types.OrgType.NONE) {\r\n            org.orgType = orgType;\r\n        }\r\n\r\n        org.orgType = orgType;\r\n        org.name = name;\r\n        org.metadataCid = metadataCid;\r\n        org.active = active;\r\n\r\n        emit OrganizationUpdated(\r\n            id,\r\n            org.wallet,\r\n            orgType,\r\n            name,\r\n            metadataCid,\r\n            active\r\n        );\r\n    }\r\n\r\n    function getOrganization(\r\n        uint256 id\r\n    ) external view returns (Types.Organization memory) {\r\n        return _orgById[id];\r\n    }\r\n}\r\n"
      },
      "project/contracts/RoleManager.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract RoleManager {\r\n    address public owner;\r\n\r\n    mapping(address => bool) public superAdmins;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    event SuperAdminSet(address indexed account, bool enabled);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlySuperAdmin() {\r\n        require(\r\n            superAdmins[msg.sender] || msg.sender == owner,\r\n            \"NOT_SUPER_ADMIN\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        superAdmins[msg.sender] = true;\r\n        emit SuperAdminSet(msg.sender, true);\r\n    }\r\n\r\n    function tranferOwnership(address newOwner) external onlyOwner {\r\n        require(newOwner != address(0), \"INVALID_ADDRESS\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    function setSuperAdmin(address account, bool enabled) external onlyOwner {\r\n        superAdmins[account] = enabled;\r\n        emit SuperAdminSet(account, enabled);\r\n    }\r\n}\r\n"
      },
      "project/libs/Types.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nlibrary Types {\r\n    enum OrgType {\r\n        NONE,\r\n        FARM,\r\n        PRCESSOR,\r\n        LOGISTICS,\r\n        RETAILER,\r\n        AUDITOR,\r\n        ADMIN\r\n    }\r\n    enum BatchStatus {\r\n        NONE,\r\n        HARVESTED,\r\n        PROCESSED,\r\n        PACKAGED,\r\n        IN_TRANSIT,\r\n        IN_WAREHOUSE,\r\n        IN_RETAIL,\r\n        SOLD,\r\n        FROZEN,\r\n        RECALLED\r\n    }\r\n\r\n    enum EventType {\r\n        NONE,\r\n        HARVEST,\r\n        PROCESS,\r\n        PACKAGE_,\r\n        SHIP_START,\r\n        SHIP_END,\r\n        WAREHOUSE_IN,\r\n        WAREHOUSE_OUT,\r\n        RETAIL_IN,\r\n        RETAIL_OUT,\r\n        SOLD,\r\n        FREEZE_,\r\n        RECALL_\r\n    }\r\n\r\n    struct Organization {\r\n        uint256 id;\r\n        address wallet;\r\n        OrgType orgType;\r\n        string name;\r\n        string metadataCid;\r\n        bool active;\r\n    }\r\n\r\n    struct Batch {\r\n        uint256 id;\r\n        uint256 parentId;\r\n        uint256 ownerOrgId;\r\n        BatchStatus status;\r\n        string productType;\r\n        string metadataCid;\r\n        bytes32 dataHash;\r\n        uint256 createdAt;\r\n    }\r\n\r\n    struct BatchEvent {\r\n        uint256 id;\r\n        uint256 batchId;\r\n        EventType eventType;\r\n        uint256 actorOrgId;\r\n        string metadataCid;\r\n        bytes32 dataHash;\r\n        uint256 at;\r\n    }\r\n\r\n    struct Certification {\r\n        uint256 id;\r\n        bytes32 subject;\r\n        uint256 issuerOrgId;\r\n        string metadataCid;\r\n        uint256 expireAt;\r\n        bool active;\r\n    }\r\n}\r\n"
      }
    }
  }
}