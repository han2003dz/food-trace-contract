{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-946427ec64e7aa87e6875056acd824f62ffafa9b",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/TraceabilityMerkleRegistry.sol": "project/contracts/TraceabilityMerkleRegistry.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 50
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/TraceabilityMerkleRegistry.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity  ^0.8.20;\r\ncontract TraceabilityMerkleRegistry {\r\n  error Unauthorized();\r\n  error ZeroAddress();\r\n  error InvalidProduct();\r\n  error InvalidBatch();\r\n  error BatchCodeAlreadyUsed();\r\n  error BatchAlreadyClosed();\r\n  error InvalidEventType();\r\n  error MerkleRootAlreadySet();\r\n  error PausedContract();\r\n  event RolesUpdated(address indexed account, uint256 roles);\r\n  event ProductCreated(\r\n    uint256 indexed productId,\r\n    address indexed owner,\r\n    string name,\r\n    string metadataURI\r\n  );\r\n  event BatchCreated(uint256 indexed batchId, uint256 indexed productId, address indexed creator, bytes32 initialDataHash);\r\n  event BatchCodeBound(uint256 indexed batchId, bytes32 indexed batchCodeHash, string batchCode);\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  event TraceEventRecorded(\r\n    uint256 indexed eventId,\r\n    uint256 indexed batchId,\r\n    EventType eventType,\r\n    address indexed actor,\r\n    uint64 timestamp,\r\n    bytes32 dataHash\r\n  );\r\n  event BatchMerkleRootCommitted(\r\n    uint256 indexed batchId,\r\n    bytes32 indexed merkleRoot,\r\n    address indexed committer\r\n  );\r\n  event Paused(address account);\r\n  event Unpaused(address account);\r\n\r\n  uint256 public constant ROLE_PRODUCER     = 1 << 0;\r\n  uint256 public constant ROLE_PROCESSOR    = 1 << 1;\r\n  uint256 public constant ROLE_TRANSPORTER  = 1 << 2;\r\n  uint256 public constant ROLE_RETAILER     = 1 << 3;\r\n  uint256 public constant ROLE_AUDITOR      = 1 << 4;\r\n\r\n  address public owner;\r\n  mapping(address => uint256) public roles;\r\n  bool public paused;\r\n\r\n  struct Product {\r\n    string name;\r\n    string metadataURI;\r\n    address owner;    \r\n    bool exists;\r\n  }\r\n\r\n  struct Batch {\r\n    uint256 productId;\r\n    address creator;         \r\n    address currentOwner;   \r\n    bytes32 initialDataHash; \r\n    bool exists;\r\n    bool closed;  \r\n  }\r\n\r\n  enum EventType {\r\n    Created,    // tạo batch\r\n    Processed,  // sơ chế/chế biến\r\n    Shipped,    // xuất kho / vận chuyển\r\n    Received,   // nhận hàng\r\n    Stored,     // lưu kho / bày bán\r\n    Sold,       // bán lẻ (kết thúc vòng đời)\r\n    Recalled,   // thu hồi (kết thúc vòng đời)\r\n    Custom      // sự kiện tùy chỉnh khác\r\n  }\r\n\r\n  struct TraceEvent {\r\n    uint256 batchId;\r\n    EventType eventType;\r\n    address actor;\r\n    uint64 timestamp;\r\n    bytes32 dataHash; // hash(data off-chain)\r\n  }\r\n\r\n  uint256 public nextProductId = 1;\r\n  uint256 public nextBatchId = 1;\r\n  uint256 public nextEventId = 1;\r\n\r\n  mapping(uint256 => Product) public products;       // productId => Product\r\n  mapping(uint256 => Batch) public batches;          // batchId => Batch\r\n  mapping(uint256 => TraceEvent) public eventsById;  // eventId => TraceEvent\r\n  mapping(uint256 => uint256[]) public batchEvents;\r\n  mapping(bytes32 => uint256) public batchCodeHashToBatchId;   // BatchCode (QR) -> batchId (1-1)\r\n  mapping(uint256 => bytes32) public batchMerkleRoot;\r\n\r\n  modifier onlyOwner() {\r\n    if (msg.sender != owner) revert Unauthorized();\r\n    _;\r\n  }\r\n  modifier whenNotPaused() {\r\n    if (paused) revert PausedContract();\r\n    _; \r\n  }\r\n  modifier onlyRole(uint256 requiredRole) {\r\n    if ((roles[msg.sender] & requiredRole) == 0 && msg.sender != owner) {\r\n      revert Unauthorized();\r\n    }\r\n    _;\r\n  }\r\n\r\n  modifier batchExists(uint256 batchId) {\r\n    if (!batches[batchId].exists) revert InvalidBatch();\r\n    _;\r\n  }\r\n\r\n  // ========= CONSTRUCTOR =========\r\n  constructor() {\r\n    owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), msg.sender);\r\n  }\r\n\r\n  // ========= ADMIN FUNCTIONS =========\r\n  function transferOwnership(address newOwner) external onlyOwner {\r\n    if (newOwner == address(0)) revert ZeroAddress();\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n  /// @notice Set roles for 1 account.\r\n  function setRoles(address account, uint256 newRoles) external onlyOwner {\r\n    if (account == address(0)) revert ZeroAddress();\r\n    roles[account] = newRoles;\r\n    emit RolesUpdated(account, newRoles);\r\n  }\r\n\r\n  function pause() external onlyOwner {\r\n    paused = true;\r\n    emit Paused(msg.sender);\r\n  }\r\n\r\n  function unpause() external onlyOwner {\r\n    paused = false;\r\n    emit Unpaused(msg.sender);\r\n  }\r\n\r\n  // ========= PRODUCT LOGIC =========\r\n\r\n  /// @notice Producer create product\r\n  function createProduct(\r\n    string calldata name,\r\n    string calldata metadataURI\r\n  ) external whenNotPaused onlyRole(ROLE_PRODUCER) returns (uint256 productId) {\r\n    productId = nextProductId++;\r\n\r\n    products[productId] = Product({\r\n        name: name,\r\n        metadataURI: metadataURI,\r\n        owner: msg.sender,\r\n        exists: true\r\n    });\r\n\r\n    emit ProductCreated(productId, msg.sender, name, metadataURI);\r\n  }\r\n\r\n  // ========= BATCH LOGIC =========\r\n\r\n  /// @notice Producer tạo Batch mới cho 1 Product\r\n  /// @param productId id của Product đã tồn tại\r\n  /// @param initialDataHash hash thông tin nguồn gốc cơ bản (JSON/IPFS,...)\r\n  function createBatch(\r\n    uint256 productId,\r\n    bytes32 initialDataHash\r\n  ) external whenNotPaused onlyRole(ROLE_PRODUCER) returns (uint256 batchId) {\r\n    Product memory p = products[productId];\r\n    if (!p.exists) revert InvalidProduct();\r\n\r\n    batchId = nextBatchId++;\r\n\r\n    batches[batchId] = Batch({\r\n        productId: productId,\r\n        creator: msg.sender,\r\n        currentOwner: msg.sender,\r\n        initialDataHash: initialDataHash,\r\n        exists: true,\r\n        closed: false\r\n    });\r\n\r\n    _recordEvent(\r\n        batchId,\r\n        EventType.Created,\r\n        msg.sender,\r\n        initialDataHash\r\n    );\r\n\r\n    emit BatchCreated(batchId, productId, msg.sender, initialDataHash);\r\n  }\r\n\r\n  /// @notice Gắn BatchCode (dùng cho QR) với batchId (1-1)\r\n    /// @dev Thường chỉ cho phép currentOwner hoặc Producer batch đó gắn\r\n    function bindBatchCode(\r\n        uint256 batchId,\r\n        string calldata batchCode\r\n    ) external whenNotPaused batchExists(batchId) {\r\n        Batch storage b = batches[batchId];\r\n        if (msg.sender != b.currentOwner && msg.sender != b.creator && msg.sender != owner) {\r\n            revert Unauthorized();\r\n        }\r\n        if (b.closed) revert BatchAlreadyClosed();\r\n\r\n        bytes32 h = keccak256(bytes(batchCode));\r\n        if (batchCodeHashToBatchId[h] != 0) revert BatchCodeAlreadyUsed();\r\n\r\n        batchCodeHashToBatchId[h] = batchId;\r\n\r\n        emit BatchCodeBound(batchId, h, batchCode);\r\n    }\r\n\r\n    // ========= TRACE EVENT LOGIC =========\r\n\r\n    /// @notice Ghi 1 TraceEvent cho batch (Process, Ship, Receive, Store, Sold, Recall, Custom)\r\n    /// @param batchId batch cần ghi\r\n    /// @param eventType loại sự kiện\r\n    /// @param dataHash hash metadata off-chain (chi tiết sự kiện)\r\n    function recordTraceEvent(\r\n        uint256 batchId,\r\n        EventType eventType,\r\n        bytes32 dataHash\r\n    ) external whenNotPaused batchExists(batchId) {\r\n        Batch storage b = batches[batchId];\r\n        if (b.closed) revert BatchAlreadyClosed();\r\n\r\n        // Kiểm tra quyền theo loại event\r\n        _requireAuthorizedForEvent(eventType, msg.sender);\r\n\r\n        // Cập nhật owner trong một số case (logic demo, bạn có thể tinh chỉnh thêm)\r\n        if (eventType == EventType.Received || eventType == EventType.Stored) {\r\n            // người nhận / nơi lưu kho trở thành currentOwner\r\n            b.currentOwner = msg.sender;\r\n        }\r\n        if (eventType == EventType.Sold || eventType == EventType.Recalled) {\r\n            // kết thúc vòng đời batch\r\n            b.currentOwner = msg.sender;\r\n            b.closed = true;\r\n        }\r\n\r\n        _recordEvent(batchId, eventType, msg.sender, dataHash);\r\n    }\r\n\r\n    function _recordEvent(\r\n        uint256 batchId,\r\n        EventType eventType,\r\n        address actor,\r\n        bytes32 dataHash\r\n    ) internal {\r\n        if (uint8(eventType) > uint8(EventType.Custom)) {\r\n            revert InvalidEventType();\r\n        }\r\n\r\n        uint256 eventId = nextEventId++;\r\n\r\n        eventsById[eventId] = TraceEvent({\r\n            batchId: batchId,\r\n            eventType: eventType,\r\n            actor: actor,\r\n            timestamp: uint64(block.timestamp),\r\n            dataHash: dataHash\r\n        });\r\n\r\n        batchEvents[batchId].push(eventId);\r\n\r\n        emit TraceEventRecorded(\r\n            eventId,\r\n            batchId,\r\n            eventType,\r\n            actor,\r\n            uint64(block.timestamp),\r\n            dataHash\r\n        );\r\n    }\r\n\r\n    function _requireAuthorizedForEvent(EventType eventType, address account) internal view {\r\n        uint256 r = roles[account];\r\n        if (account == owner) return;\r\n\r\n        if (eventType == EventType.Created) {\r\n            if ((r & ROLE_PRODUCER) == 0) revert Unauthorized();\r\n        } else if (eventType == EventType.Processed) {\r\n            if ((r & (ROLE_PRODUCER | ROLE_PROCESSOR)) == 0) revert Unauthorized();\r\n        } else if (eventType == EventType.Shipped) {\r\n            if ((r & (ROLE_PRODUCER | ROLE_PROCESSOR | ROLE_TRANSPORTER)) == 0) revert Unauthorized();\r\n        } else if (eventType == EventType.Received) {\r\n            if ((r & (ROLE_PROCESSOR | ROLE_RETAILER)) == 0) revert Unauthorized();\r\n        } else if (eventType == EventType.Stored) {\r\n            if ((r & (ROLE_RETAILER | ROLE_PROCESSOR)) == 0) revert Unauthorized();\r\n        } else if (eventType == EventType.Sold) {\r\n            if ((r & ROLE_RETAILER) == 0) revert Unauthorized();\r\n        } else if (eventType == EventType.Recalled) {\r\n            if ((r & (ROLE_PRODUCER | ROLE_RETAILER | ROLE_AUDITOR)) == 0) revert Unauthorized();\r\n        } else if (eventType == EventType.Custom) {\r\n            // Cho phép nhiều bên, tuỳ use-case; ở đây yêu cầu phải có ít nhất 1 role\r\n            if (r == 0) revert Unauthorized();\r\n        }\r\n    }\r\n\r\n    // ========= MERKLE ROOT (OPTIONAL, CHO DATA OFF-CHAIN) =========\r\n\r\n    /// @notice Auditor (hoặc Owner) commit Merkle root chứa full log off-chain của batch.\r\n    ///         Dùng để chứng minh dữ liệu off-chain không bị sửa.\r\n    function commitBatchMerkleRoot(\r\n        uint256 batchId,\r\n        bytes32 merkleRoot\r\n    ) external whenNotPaused batchExists(batchId) {\r\n        if (merkleRoot == bytes32(0)) revert InvalidEventType();\r\n        if (batchMerkleRoot[batchId] != bytes32(0)) revert MerkleRootAlreadySet();\r\n\r\n        uint256 r = roles[msg.sender];\r\n        if (msg.sender != owner && (r & ROLE_AUDITOR) == 0) revert Unauthorized();\r\n\r\n        batchMerkleRoot[batchId] = merkleRoot;\r\n        emit BatchMerkleRootCommitted(batchId, merkleRoot, msg.sender);\r\n    }\r\n\r\n    /// @notice Verify Merkle proof off-chain log (utility cho client).\r\n    function verifyWithRoot(\r\n        bytes32 leaf,\r\n        bytes32 root,\r\n        bytes32[] calldata proof\r\n    ) external pure returns (bool) {\r\n        return _computeRootFromProof(leaf, proof) == root;\r\n    }\r\n\r\n    function _computeRootFromProof(\r\n        bytes32 leaf,\r\n        bytes32[] calldata proof\r\n    ) internal pure returns (bytes32) {\r\n        bytes32 computed = leaf;\r\n        uint256 len = proof.length;\r\n        for (uint256 i = 0; i < len; ) {\r\n            bytes32 p = proof[i];\r\n            if (computed < p) {\r\n                computed = keccak256(abi.encodePacked(computed, p));\r\n            } else {\r\n                computed = keccak256(abi.encodePacked(p, computed));\r\n            }\r\n            unchecked { ++i; }\r\n        }\r\n        return computed;\r\n    }\r\n\r\n    // ========= VIEW HELPERS =========\r\n\r\n    function hasRole(address account, uint256 role) external view returns (bool) {\r\n        return (roles[account] & role) != 0;\r\n    }\r\n\r\n    function getBatchEvents(uint256 batchId) external view returns (uint256[] memory) {\r\n        return batchEvents[batchId];\r\n    }\r\n}\r\n"
      }
    }
  }
}